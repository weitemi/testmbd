/*
 * Temp.c
 *
 *  Created on: 2019年1月7日
 *      Author: Lenovo
 */

#include "Cpu.h"
#include "clockMan1.h"
#include "dmaController1.h"
#include "pin_mux.h"
#include "SYS.h"
#include "CAN.h"
#include "LPIT.h"
#include "ADC.h"
#include "Temp.h"
#include "Data_Hand.h"
#include <stdint.h>
#include <stdbool.h>
#include <string.h>


uint16_t temp_data[136]=
{
	54740,51864,49155,46602,44195,41927,39787,37769,35865,34067,
	32371,30768,29254,27824,26471,25193,23983,22839,21756,20730,
	19759,18839,17967,17140,16356,15612,14907,14237,13601,12997,
	12423,11878,11359,10866,10397,10000,9527,9122,8738,8371,
	8022,7689,7371,7069,6780,6505,6242,5992,5752,5524,
	5306,5097,4898,4707,4525,4351,4185,4025,3873,3727,
	3588,3454,3326,3203,3086,2973,2865,2762,2662,2567,
	2476,2389,2305,2224,2147,2072,2001,1932,1866,1803,
	1695,1638,1583,1530,1479,1430,1382,1337,1293,1290,
	1249,1209,1171,1134,1099,1065,1032,1000,969,940,
	911,884,857,832,807,783,760,738,717,696,
	677,657,638,620,602,586,569,554,538,524,
	509,496,482,469,457,445,433,422,411,400,
	390,380,370,360,351,342
};

//Honeywell传感器标定数据（从-40℃-120℃）
uint16_t Honeywell_data[161] =
{
	31315,30345,28430,26915,26025,25165,23455,22060,20840,19750,  //从-40℃  ~ -31℃
	18430,17505,16420,15585,14665,13865,13080,12155,11625,11005,  //从-30℃  ~ -21℃
	10340,9860,9380,8745,8325,7940,7565,7130,6740,6440,           //从-20℃  ~ -11℃
	6095,5765,5495,5210,4950,4695,4398,4208,4015,3792,            //从-10℃  ~ -1℃
	3643,3447,3275,3100,2970,2825,2694,2564,2426,2325,            //从0℃  ~ 9℃
	2204,1982,1950,1910,1828,1753,1679,1564,1507,1440,            //从10℃  ~ 19℃
	1369,1315,1245,1199,1147,1091,1046,998,958,920,               //从20℃  ~ 29℃
	868,837,804,773,741,716,692,662,633,607,                      //从30℃  ~ 39℃
	577,558,538,520,496,476,459,438,424,413,                      //从40℃  ~ 49℃
	395,380,366,355,340,328,313,305,276,265,                      //从50℃  ~ 59℃
	258,249,240,231,224,216,209,202,197,191,                      //从60℃  ~ 69℃
	184,177,171,166,158,154,150,145,139,135,                      //从70℃  ~ 79℃
	131,127,123,119,116,112,109,105,102,99,                       //从80℃  ~ 89℃
	97,93,90,88,86,85,83,80,77,76,                                //从90℃  ~ 99℃
	73,70,67,65,64,62,60,58,57,55,                                //从100℃  ~ 109℃
	54,52,51,50,49,47,46,45,43,42,                                //从110℃  ~ 119℃
	41                                                            //120℃

//	10067,9641,9184,8677,8226,7804,7347,6951,6607,6251,
//	5950,5636,5314,5040,4800,4525,4307,4100,3877,3671,
//	3503,3238,3062,2919,2761,2618,2456,2358,2260,2127,
//	2039,1942,1861,1770,1690,1617,1546,1470,1404,1344,
//	1280,1245,1177,1124,1075,1027,980,940,897,860,
//	822,785,754,727,691,663,633,605,579,555,
//	531,510,492,472,453,435,417,399,383,369,
//	351,336,325,312,299,289,277,264,254,243,
//	235,227,218,208,199,193,185,177,170,164,
//	158,152,146,139,135,129,125,119,115,109,
//	105,103,96,92,90,86,82,80,78,72,
//	70,68,64,62,60,58,56,52,50,48,
//	46,45,42,40,38,37,35,34,31,30,
//	29,28,26,25,24,23,20,19,18,17,
//	16
};

// ASCO排氢阀传感器标定数据（从-40℃-100℃） NTC10K
uint16_t ASCO_data[141] =
{
	31200,29200,28800,28100,27400,25800,23600,22800,21300,20000, //从-40℃ --31℃
	19500,18600,17000,15600,14800,14200,13600,13000,12200,11200, //从-30℃ --21℃
	10700,10300,10100,9400,9000,8300,7760,7430,6890,6630, //从-20℃ --11℃
	6200,5770,5570,5130,4900,4770,4580,4400,3880,3820, //从-10℃ --1℃
	3700,3556,3380,3257,3050,2910,2845,2653,2536,2391, //从0℃ -9℃
	2277,2172,2070,1973,1900,1820,1700,1663,1543,1480, //从9℃ -19℃
	1427,1400,1373,1337,1284,1241,1201,1178,1147,1110, //从20℃ -29℃
	1024,965,921,901,852,800,770,745,727,660, //从30℃ -39℃
	623,590,578,551,543,512,483,469,455,441, //从40℃ -49℃
	427,414,401,388,375,345,332,320,307,298, //从50℃ -59℃
	294,286,272,261,252,245,237,229,211,205, //从60℃ -69℃
	196,192,185,178,173,163,159,156,152,148, //从70℃ -79℃
	142,137,129,126,123,119,116,113,107,104,    //从80℃ -89℃
	98,97,94,92,90,89,88,87,86,85,           //从90℃ -99℃
	84						   //100℃

//	312000,292000,288000,281000,274000,258000,236000,228000,213000,200000, //从-40℃ --31℃
//		195000,186000,170000,156000,148000,142000,136000,130000,122000,112000, //从-30℃ --21℃
//		107000,103000,101000,94000,90000,83000,77600,74300,68900,66300, //从-20℃ --11℃
//		62000,57700,55700,51300,49000,47700,45800,44000,38800,38200, //从-10℃ --1℃
//		37000,35560,33800,32570,30500,29100,28450,26530,25360,23910, //从0℃ -9℃
//		22770,21720,20700,19730,19000,18200,17000,16630,15430,14800, //从9℃ -19℃
//		14270,14000,13730,13370,12840,12410,12010,11780,11470,11100, //从20℃ -29℃
//		10240,9650,9210,9010,8520,8000,7700,7450,7270,6600, //从30℃ -39℃
//		6230,5900,5780,5510,5430,5120,4830,4690,4550,4410, //从40℃ -49℃
//		4270,4140,4010,3880,3750,3450,3320,3200,3070,2980, //从50℃ -59℃
//		2940,2860,2720,2610,2520,2450,2370,2290,2110,2050, //从60℃ -69℃
//		1960,1920,1850,1780,1730,1630,1590,1560,1520,1480, //从70℃ -79℃
//		1420,1370,1290,1260,1230,1190,1160,1130,1070,1040,    //从80℃ -89℃
//		980,970,940,920,900,890,880,870,860,850,           //从90℃ -99℃
//		840							   //100℃
};

//空气流量数据
uint16_t Flowmeter_data[39][2]={{1000,0},{1257,8},{1329,10},{1488,15},{1838,30},{2325,60},{2703,106},{2775,112},{2860,120},{2913,131},{2965,136},
		{3056,147},{3114,157},{3190,162},{3206,171},{3252,181},{3314,191},{3340,205},{3398,209},{3452,222},{3520,234},{3551,243},{3590,251},
		{3641,262},{3669,273},{3727,280},{3742,290},{3777,300},{3800,311},{3855,326},{3880,339},{3924,348},{3990,361},{4015,375},{4041,386},
		{4079,400},{4123,413},{4344,480},{4954,600}};//12571,13289,14876,18380,23252,29072,36237,40448,43441};
uint16_t Flowmeter_dataLng=39;
//温度换算函数
uint8_t Temp_Rec(uint16_t AD_DY)
{
	uint16_t Temp_RES=0;
	uint8_t Temp=0;
	if(AD_DY>=5000)AD_DY=4999;
	Temp_RES = ((10000*AD_DY)/(5000-AD_DY));//2000代表2K分压电阻，如果10K就用10 000就行。
	Temp = FineTab(temp_data,Temp_RES)+30+3;//因为他就偏移了-10度，最终计算的时候它便宜了-40度，所以要加30 加3是根据标定来的

	return Temp;
}
//ASCO温度换算函数
uint8_t Temp_Rec1(uint32_t AD_DY)
{
	uint16_t Temp_RES=0;
	uint16_t Temp=0;
	if(AD_DY>=343632)AD_DY=340000;
	Temp_RES = AD_DY/10;
	Temp = FineTab(ASCO_data,Temp_RES);//偏移了-40度，最终计算的时候偏移-80度，所以要加40
	return Temp;
}

////5V跟采集口 温度换算函数
//uint8_t Temp_Rec1(uint16_t AD_DY)
//{
//	uint16_t Temp_RES=0;
//	uint8_t Temp=0;
//	if(AD_DY>=5000)AD_DY=4999;
//	Temp_RES = ((10000*(5000-AD_DY))/AD_DY);//2000代表2K分压电阻，如果10K就用10 000就行。
//	Temp = FineTab(temp_data,Temp_RES)+30-1;//因为他就偏移了-10度，最终计算的时候它便宜了-40度，所以要加30  减1是根据标定来的
//	return Temp;
//}

uint8_t Temp_Rec2(uint16_t AD_DY)
{
	uint16_t Temp_RES=0;
	uint16_t Temp=0;
//	if(AD_DY>=5000)AD_DY=4999;
	Temp_RES = AD_DY;
//	Temp_RES = (uint16_t)(((uint32_t)(10000*AD_DY))/(5000-AD_DY));

	Temp = FineTab(Honeywell_data,Temp_RES);//偏移了-20度，最终计算的时候偏移-40度，所以要加20

	return Temp;
}

//输入数组，比较数值
uint8_t FineTab(uint16_t *a,uint16_t data)//二分法查表
{
	uint8_t st,ed,m ;
	uint8_t i ;

    st = 0 ;
    ed = 135 ;
    i = 0  ;

    if(data >= a[st]) return st ;
    else if(data <= a[ed]) return ed ;

    while(st < ed)
    {
        m = (st+ed)/2 ;

        if(data == a[m] ) break ;
        if(data < a[m] && data > a[m+1]) break ;


        if(data > a[m])  ed = m ;
        else st = m ;

        if(i++ > 135) break ;
    }

    if(st > ed ) return 0 ;

    return m ;
}










uint16_t Flowmeter_Rec(uint16_t AD_FT)
{
	uint16_t AD_FTTest=0;
	uint16_t FT_Temp = 0;


	AD_FTTest = AD_FT;
//	AD_FTTest = AD_FT;
	FT_Temp = GetLineValue(Flowmeter_data, AD_FTTest, Flowmeter_dataLng);
//	G_Air = FT_Temp;

	return FT_Temp;
}
//二维查表
uint32_t GetLineValue(uint16_t A_array[][2], uint16_t x0, uint16_t length)
{
	uint16_t Yaxis = 0;// Y轴数据
	uint16_t Left = 0;// 循环变量右值
	uint16_t Middle = 0;// 中间值
	uint16_t Right = 0;// 循环变量左值
	uint16_t CalFlag = 0;//

    if (x0 <= A_array[0][0])                        // 限制最小值
    {
        Yaxis = A_array[0][1];
    }
    else if (x0 >= A_array[length - 1][0])          // 限制最大值
    {
        Yaxis = A_array[length - 1][1];
    }
    else                                            // 二分查表算法
    {
        Right = length;

        while (Left < Right - 1)                    // 循环比较，不满足左
        {                                           // 值小于右值时退出

            Middle = (Left + Right) >> 1;           // 取中间值

            if (x0 < A_array[Middle][0])            // 若X小于中间值对应的
            {                                       // 值，则右值等于中间值
                Right = Middle;
            }
            else if (x0 > A_array[Middle][0])       // 否则左值等于中间值
            {
                Left = Middle;
            }
            else
            {
                Yaxis = A_array[Middle][1];
                CalFlag = 1;
                break;
            }
        }

        // 根据二分法计算的i值进行内差运算---------------------------------
        if (0 == CalFlag)
        {
            Yaxis = (uint32_t)(A_array[Left + 1][1] - A_array[Left][1]) \
                    * (x0 - A_array[Left][0]) / (A_array[Left + 1][0] - A_array[Left][0]) \
                    + A_array[Left][1];
        }
		else
		{

		}
    }

    return (Yaxis);
}
